<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Mathematical modeling - tanh-blog</title><meta name="description" content="import numpy as np # 构造判断矩阵 A = np.array([[1,5,3,2],[1/5,1,1/2,1/3],[1/3,2,1,1/2],[1/2,3,2,1]]) #&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://tanhhhhtjy.github.io/shu-xue-jian-mo.html"><link rel="alternate" type="application/atom+xml" href="https://tanhhhhtjy.github.io/feed.xml" title="tanh-blog - RSS"><link rel="alternate" type="application/json" href="https://tanhhhhtjy.github.io/feed.json" title="tanh-blog - JSON"><meta property="og:title" content="Mathematical modeling"><meta property="og:site_name" content="tanh-blog"><meta property="og:description" content="import numpy as np # 构造判断矩阵 A = np.array([[1,5,3,2],[1/5,1,1/2,1/3],[1/3,2,1,1/2],[1/2,3,2,1]]) #&hellip;"><meta property="og:url" content="https://tanhhhhtjy.github.io/shu-xue-jian-mo.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://tanhhhhtjy.github.io/assets/css/style.css?v=af24a907945dc2113f54315587072373"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://tanhhhhtjy.github.io/shu-xue-jian-mo.html"},"headline":"Mathematical modeling","datePublished":"2025-08-26T22:40+08:00","dateModified":"2025-08-26T23:01+08:00","description":"import numpy as np # 构造判断矩阵 A = np.array([[1,5,3,2],[1/5,1,1/2,1/3],[1/3,2,1,1/2],[1/2,3,2,1]]) #&hellip;","author":{"@type":"Person","name":"tanh","url":"https://tanhhhhtjy.github.io/authors/tanh/"},"publisher":{"@type":"Organization","name":"tanh"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
  }
};</script></head><body class="post-template"><style>body {
    background-color: #B8A5D2 !important;
}</style><section id="nice" style="background-attachment: scroll; background-clip: border-box; background-color: rgba(0, 0, 0, 0); background-image: none; background-origin: padding-box; background-position-x: 0%; background-position-y: 0%; background-repeat: no-repeat; background-size: auto; width: auto; font-family: Optima, PingFangSC-light, serif; font-size: 16px; color: #000000; line-height: 1.5em; word-spacing: 0em; letter-spacing: 0em; word-break: break-word; overflow-wrap: break-word; text-align: left; padding: 0px 10px 0px 10px; margin: 0px;" data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><header class="top js-header"><a class="logo" href="https://tanhhhhtjy.github.io/">tanh-blog</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Mathematical modeling</h1><div class="feed__meta content__meta"><a href="https://tanhhhhtjy.github.io/authors/tanh/" class="feed__author">tanh</a> <time datetime="2025-08-26T22:40" class="feed__date">August 26, 2025</time></div></div></header></div><div class="entry-wrapper content__entry"><div id="geometric-bg" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c); background-size: 400% 400%; animation: gradientShift 15s ease infinite;"></div><p> </p><div style="text-align: center; margin-bottom: 50px; padding: 30px 20px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); border-radius: 10px;"><h1 style="font-size: 2.5em; color: #2c3e50; margin-bottom: 10px; font-weight: bold;"><em>Evaluations</em></h1><p style="font-size: 1.2em; color: #7f8c8d; margin: 0;"> </p></div><div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><h2 style="color: #2c3e50; margin-bottom: 20px; padding-left: 10px; border-left: 4px solid #3498db;"> 层次分析法 (AHP)</h2><h3 style="color: #34495e; margin-bottom: 15px;">算法步骤：</h3><ol style="line-height: 1.8; color: #555;"><li><strong>建立层次结构模型：</strong> 构建目标层-准则层-方案层的层次结构</li><li><strong>归一化处理：</strong> 消除量纲，得到各方案在各指标中的得分</li><li><strong>构造判断矩阵：</strong> 各指标两两比较，进行一致性检验</li><li><strong>计算权重：</strong> 使用算术平均法、几何平均法、特征向量法</li></ol><div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0;"><strong>一致性检验公式：</strong><br><code style="background: white; padding: 2px 5px; border-radius: 3px;">CR = CI/RI &lt; 0.1</code></div><details style="margin-top: 20px;"><summary style="cursor: pointer; font-weight: bold; color: #3498db; padding: 10px; background: #f8f9fa; border-radius: 5px;">Codes</summary><pre style="background: #2d3748; color: #ffffff; padding: 20px; border-radius: 5px; overflow-x: auto; margin-top: 10px;"><code>import numpy as np

# 构造判断矩阵
A = np.array([[1,5,3,2],[1/5,1,1/2,1/3],[1/3,2,1,1/2],[1/2,3,2,1]])

# 一致性检验
eig_val, eig_vec = np.linalg.eig(A)
max_val = max(eig_val)
n = A.shape[0]
CI = (max_val - n)/(n - 1)
RI = [0,0.0001,0.52,0.89,1.12,1.26,1.36,1.41,1.46,1.49]
CR = CI / RI[n-1]

# 特征向量法求权重
max_index = np.argmax(eig_val)
max_vector = eig_vec[:,max_index]
weights = max_vector / np.sum(max_vector)</code></pre></details></div><div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><h2 style="color: #2c3e50; margin-bottom: 20px; padding-left: 10px; border-left: 4px solid #e74c3c;"> TOPSIS法</h2><h3 style="color: #34495e; margin-bottom: 15px;">算法步骤：</h3><ol style="line-height: 1.8; color: #555;"><li><strong>原始矩阵正向化：</strong> 将指标数据转化成极大指标</li><li><strong>矩阵标准化：</strong> 消除不同指标的量纲</li><li><strong>找出理想解：</strong> 确定理想最优解与理想最劣解</li><li><strong>计算距离与得分：</strong> 计算各方案与理想解的距离</li></ol><div style="background: #fff5f5; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #e74c3c;"><strong>核心公式：</strong><br>标准化：<code style="background: white; padding: 2px 5px; border-radius: 3px;">z_ij = x_ij / √(Σx_ij²)</code><br>最终得分：<code style="background: white; padding: 2px 5px; border-radius: 3px;">S_i = D_i⁻ / (D_i⁻ + D_i⁺)</code></div><details style="margin-top: 20px;"><summary style="cursor: pointer; font-weight: bold; color: #e74c3c; padding: 10px; background: #f8f9fa; border-radius: 5px;">Codes</summary><pre style="background: #2d3748; color: #ffffff; padding: 20px; border-radius: 5px; overflow-x: auto; margin-top: 10px;"><code>import numpy as np

# 矩阵标准化
for j in range(m):
    X[:,j] = X[:,j] / np.sqrt(sum(X[:,j] ** 2))

# 计算理想解
x_max = np.max(X, axis=0)
x_min = np.min(X, axis=0)

# 计算距离
d_pos = np.sqrt(np.sum(w * np.square((X-np.tile(x_max,(n,1)))), axis=1))
d_neg = np.sqrt(np.sum(w * np.square((X-np.tile(x_min,(n,1)))), axis=1))

# 计算得分
s = d_neg / (d_neg + d_pos)</code></pre></details></div><div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><h2 style="color: #2c3e50; margin-bottom: 20px; padding-left: 10px; border-left: 4px solid #f39c12;"> 熵权法</h2><div style="background: #fff9e6; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-left: 4px solid #f39c12;"><strong>核心思想：</strong> 指标数据离散程度越大，信息熵越小，权重越高</div><h3 style="color: #34495e; margin-bottom: 15px;">算法步骤：</h3><ol style="line-height: 1.8; color: #555;"><li><strong>原始矩阵正向化：</strong> 同TOPSIS法</li><li><strong>矩阵标准化：</strong> 消除不同指标的量纲</li><li><strong>矩阵归一化：</strong> 控制在[0,1]之间</li><li><strong>计算熵权：</strong> 根据信息熵计算各指标权重</li></ol><div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0;"><strong>核心公式：</strong><br>归一化：<code style="background: white; padding: 2px 5px; border-radius: 3px;">p_ij = z_ij / Σz_ij</code><br>信息熵：<code style="background: white; padding: 2px 5px; border-radius: 3px;">e_j = -1/ln(n) × Σp_ij×ln(p_ij)</code><br>熵权：<code style="background: white; padding: 2px 5px; border-radius: 3px;">W_j = (1-e_j) / Σ(1-e_j)</code></div><details style="margin-top: 20px;"><summary style="cursor: pointer; font-weight: bold; color: #f39c12; padding: 10px; background: #f8f9fa; border-radius: 5px;">Codes</summary><pre style="background: #2d3748; color: #ffffff; padding: 20px; border-radius: 5px; overflow-x: auto; margin-top: 10px;"><code>import numpy as np

def mylog(p):
    n = len(p)
    lnp = np.zeros(n)
    for i in range(n):
        if p[i] == 0:
            lnp[i] = 0
        else:
            lnp[i] = np.log(p[i])
    return lnp

# 标准化
Z = X / np.sqrt(np.sum(X**2, axis=0))

# 归一化
P = Z / np.sum(Z, axis=0)

# 计算信息效用值
n, m = P.shape
D = np.zeros(m)
for j in range(m):
    p = P[:,j]
    e = -np.sum(p * mylog(p)) / np.log(n)
    D[j] = 1 - e

# 计算熵权
W = D / np.sum(D)</code></pre></details></div><div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><h2 style="color: #2c3e50; margin-bottom: 20px; padding-left: 10px; border-left: 4px solid #9b59b6;">模糊综合评价</h2><div style="background: #f4f1f8; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-left: 4px solid #9b59b6;"><strong>核心思想：</strong> 确定隶属函数，处理模糊性问题</div><h3 style="color: #34495e; margin-bottom: 15px;">算法步骤：</h3><ol style="line-height: 1.8; color: #555;"><li><strong>确定隶属函数：</strong> 模糊统计法、指派法等</li><li><strong>计算隶属值：</strong> 数据隶属于目标集合的程度</li><li><strong>确定权重：</strong> 使用层次分析法、熵权法等</li><li><strong>综合评价：</strong> 计算加权综合得分</li></ol><div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0;"><strong>主要方法：</strong><br>• <strong>模糊统计法：</strong> 通过调查问卷或专家打分<br>• <strong>指派法：</strong> 主观指派隶属函数（常用）<br>• <strong>客观尺度法：</strong> 借助已有客观尺度</div><details style="margin-top: 20px;"><summary style="cursor: pointer; font-weight: bold; color: #9b59b6; padding: 10px; background: #f8f9fa; border-radius: 5px;">Codes</summary><pre style="background: #2d3748; color: #ffffff; padding: 20px; border-radius: 5px; overflow-x: auto; margin-top: 10px;"><code>import numpy as np

# 单因素评价矩阵
R = np.array([
    [0.18,0.14,0.18,0.14,0.13,0.23],
    [0.15,0.20,0.15,0.25,0.10,0.15],
    [0.25,0.12,0.13,0.12,0.18,0.20]
])

# 使用熵权法计算权重
n, m = R.shape
D = np.zeros(n)
for i in range(n):
    p = R[i,:]
    e = -np.sum(p*mylog(p)) / np.log(m)
    D[i] = 1 - e

W = D / np.sum(D)
A = np.array(W)

# 模糊综合评价
B = np.dot(A, R)</code></pre></details></div><div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><h2 style="color: #2c3e50; margin-bottom: 20px; padding-left: 10px; border-left: 4px solid #95a5a6;"> 灰色关联分析</h2><div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; border-left: 4px solid #95a5a6;"><strong>核心思想：</strong> 计算变量间的关联度</div><h3 style="color: #34495e; margin-bottom: 15px;">算法步骤：</h3><ol style="line-height: 1.8; color: #555;"><li><strong>正向化统一量纲：</strong> 数据预处理，消除量纲影响</li><li><strong>计算差值：</strong> 所有子序列与母序列的差值</li><li><strong>求关联系数：</strong> 使用分辨系数ρ（一般取0.5）</li><li><strong>计算关联度：</strong> 进行评价排序</li></ol><div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0;"><strong>关联系数公式：</strong><br><code style="background: white; padding: 2px 5px; border-radius: 3px;">ξ_ij = (a + ρb) / (X_ij + ρb)</code><br>其中：a = 两级最小差，b = 两级最大差，ρ = 0.5（分辨系数）</div><details style="margin-top: 20px;"><summary style="cursor: pointer; font-weight: bold; color: #95a5a6; padding: 10px; background: #f8f9fa; border-radius: 5px;">Codes</summary><pre style="background: #2d3748; color: #ffffff; padding: 20px; border-radius: 5px; overflow-x: auto; margin-top: 10px;"><code>import numpy as np

# 数据预处理
Mean = np.mean(A, axis=0)
A_norm = A / Mean

# 确定母序列和子序列
Y = A_norm[:,0]  # 母序列
X = A_norm[:,1:]  # 子序列

# 计算绝对差矩阵
absX0_Xi = np.abs(X - np.tile(Y.reshape(-1,1), (1,X.shape[1])))

# 计算两级最小差和最大差
a = np.min(absX0_Xi)
b = np.max(absX0_Xi)

# 分辨系数
rho = 0.5

# 关联系数计算
xi = (a + rho * b) / (absX0_Xi + rho * b)

# 关联度计算
grey_relation = np.mean(xi, axis=0)</code></pre></details></div></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on August 26, 2025</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://tanhhhhtjy.github.io/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://tanhhhhtjy.github.io/authors/tanh/" rel="author">tanh</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://tanhhhhtjy.github.io/xiao-shi-niu-dao.html" class="content__nav-link" rel="prev"><div><span>Previous</span> 小试牛刀</div></a></div><div class="content__nav-next"><a href="https://tanhhhhtjy.github.io/1.html" class="content__nav-link" rel="next"><div><span>Next</span> 堆叠n本书最多能达到多远</div></a></div></div></div></nav></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://tanhhhhtjy.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://tanhhhhtjy.github.io/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></section></body></html>